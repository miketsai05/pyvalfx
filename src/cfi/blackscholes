"""
Module for Black Scholes formula
"""

import numpy as np
from scipy.stats import norm

class BlackScholes:
    def __init__(self, S, K, T, sigma, r, q=0):
        """
        Initializes the Black-Scholes class with the given parameters.

        Parameters:
        S: The spot price of the underlying asset
        K: The strike price
        T: The time to maturity (in years)
        sigma: The volatility of the underlying asset
        r: The risk-free interest rate
        q: The continuous dividend yield (default is 0)
        """

        if any(x <= 0 for x in [T, sigma, r]):
            raise ValueError("Expected inputs T, sigma, rfr to be greater than 0.")
        if any(x < 0 for x in [S, K]):
            raise ValueError("Expected inputs S, K to be greater than or equal to 0")

        self.S = np.asarray(S)
        self.K = np.asarray(K)
        self.T = np.asarray(T)
        self.r = np.asarray(r)
        self.sigma = np.asarray(sigma)

        # Check if all non-scalar inputs have the same dimensions
        shapes = [x.shape for x in [self.S, self.K, self.T, self.r, self.sigma] if x.ndim > 0]
        if len(set(shapes)) > 1:
            raise ValueError("All non-scalar inputs must have the same dimensions.")

        self.d1, self.d2 = self.calculate_d1_d2()

    def calculate_d1_d2(self):
        """
        Calculates the d1 and d2 values used in the Black-Scholes formula.

        Returns:
        The d1 and d2 values.
        """
        d1 = (np.log(self.S / self.K) + (self.r + 0.5 * self.sigma ** 2) * self.T) / (self.sigma * np.sqrt(self.T))
        d2 = d1 - self.sigma * np.sqrt(self.T)
        return d1, d2

    def call_price(self):
        """
        Calculates the price of a European call option using the Black-Scholes formula.

        Returns:
        The price of the European call option.
        """
        call_price = self.S * norm.cdf(self.d1) - self.K * np.exp(-self.r * self.T) * norm.cdf(self.d2)
        return call_price